<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Guide to Java Agents</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chosen Palette: Calm Neutrals (#F8F5F2, #333333, #4A5568, #6A8EAE) -->
    <!-- Application Structure Plan: The SPA uses a thematic, non-linear structure with a persistent side navigation. This allows users to freely explore concepts without being locked into the linear flow of the original report. The main themes are: Overview (Why), JVM & ClassLoading (How it Works), Agent Lifecycle (Core Patterns), Instrumentation API (The Tools), Bytecode Libraries (The Ecosystem), a consolidated Code Lab (Practical Examples), and Production Guide (Best Practices). This information architecture prioritizes user-driven learning, allowing both novices and experienced developers to find relevant information quickly. For example, a developer can jump directly to the Bytecode library comparison or the Code Lab without having to scroll through foundational theory. -->
    <!-- Visualization & Content Choices: 
        - JVM Startup: Report Info -> 7-step startup process. Goal -> Explain a sequence. Viz/Method -> Interactive vertical stepper/timeline created with HTML/CSS/JS. Interaction -> Clicking a step reveals details. Justification -> More engaging and less overwhelming than a large block of text or static diagram. Method -> Custom JS with Tailwind.
        - ClassLoader Hierarchy: Report Info -> Delegation model. Goal -> Explain a hierarchical process. Viz/Method -> Interactive diagram with HTML/CSS/JS. Interaction -> User input triggers an animation showing the delegation flow. Justification -> Visually demonstrates the abstract concept of delegation in a memorable way. Method -> Custom JS with Tailwind.
        - Bytecode Library Comparison: Report Info -> Table comparing ASM, Javassist, Byte Buddy. Goal -> Aid decision-making. Viz/Method -> Bar chart (Chart.js) for high-level comparison (Performance vs. Ease of Use) paired with a detailed HTML table. Interaction -> Chart tooltips. Justification -> A visual chart provides an instant summary, while the table offers details on demand. Library -> Chart.js.
        - Code Examples: Report Info -> Multiple Java and manifest code snippets. Goal -> Provide clear, usable code. Viz/Method -> Consolidated "Code Lab" section with tabbed views for each project and a "copy-to-clipboard" feature. Interaction -> Tabs to switch between files, button to copy code. Justification -> Organizes all practical examples in one place and improves usability. Method -> Custom JS.
        - Tables: Report Info -> Comparisons of ClassLoaders, redefine vs. retransform. Goal -> Clear comparison. Viz/Method -> Styled HTML tables. Interaction -> None needed. Justification -> Standard, effective way to present structured data. Method -> Tailwind CSS.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        .content-section { display: none; }
        .content-section.active { display: block; }
        
        .nav-link.active {
            background-color: #6A8EAE;
            color: white;
        }
        .nav-link {
            transition: all 0.2s ease-in-out;
        }
        .nav-link:hover {
            background-color: #EBF8FF;
            color: #4A5568;
        }

        .code-block {
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4A5568;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .code-block:hover .copy-button {
            opacity: 1;
        }
        .copy-button:active {
            background-color: #2D3748;
        }

        .chart-container {
            position: relative;
            margin: auto;
            height: 350px;
            width: 100%;
            max-width: 600px;
        }

        .flow-step-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-[#F8F5F2] text-[#333333]">

    <div class="flex flex-col md:flex-row min-h-screen">
        <!-- Sidebar Navigation -->
        <nav class="md:w-64 bg-white p-4 md:p-6 shadow-lg md:h-screen md:sticky top-0">
            <h1 class="text-2xl font-bold text-[#4A5568] mb-6">Java Agents</h1>
            <ul class="space-y-2" id="main-nav">
                <li><a href="#overview" class="nav-link block w-full text-left font-medium p-3 rounded-lg">Overview</a></li>
                <li><a href="#jvm-internals" class="nav-link block w-full text-left font-medium p-3 rounded-lg">JVM & ClassLoading</a></li>
                <li><a href="#agent-lifecycle" class="nav-link block w-full text-left font-medium p-3 rounded-lg">Agent Lifecycle</a></li>
                <li><a href="#instrumentation-api" class="nav-link block w-full text-left font-medium p-3 rounded-lg">Instrumentation API</a></li>
                <li><a href="#bytecode-libraries" class="nav-link block w-full text-left font-medium p-3 rounded-lg">Bytecode Libraries</a></li>
                <li><a href="#code-lab" class="nav-link block w-full text-left font-medium p-3 rounded-lg">Code Lab</a></li>
                <li><a href="#production-guide" class="nav-link block w-full text-left font-medium p-3 rounded-lg">Production Guide</a></li>
            </ul>
        </nav>

        <!-- Main Content -->
        <main class="flex-1 p-6 md:p-10">
            <!-- Overview Section -->
            <section id="overview" class="content-section space-y-8">
                <header>
                    <h2 class="text-4xl font-bold text-[#4A5568] mb-2">The Art of Java Instrumentation</h2>
                    <p class="text-xl text-gray-600">A deep dive into the powerful world of Java Agents.</p>
                </header>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">What is a Java Agent?</h3>
                    <p class="text-gray-700 leading-relaxed">
                        A Java Agent is a specially packaged JAR file designed to instrument programs running on the JVM. The term <strong>instrumentation</strong> refers to adding or modifying the bytecode of methods to gather data or alter their behavior, all without changing the application's original source code. This powerful capability, enabled by the standard `java.lang.instrument` API, allows trusted tools like profilers, monitors, and debuggers to hook into the very core of the JVM. It provides a sanctioned "escape hatch" from Java's standard safety guarantees, enabling a whole class of powerful runtime manipulations.
                    </p>
                </div>
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">Why Use an Agent? The Power of Instrumentation</h3>
                    <p class="text-gray-700 leading-relaxed mb-4">
                        By registering a `ClassFileTransformer`, an agent can intercept every class as it's being loaded by the JVM, receiving its raw bytecode. This simple hook enables a wide array of powerful use cases that are critical for modern software development and operations.
                    </p>
                    <ul class="list-disc list-inside space-y-2 text-gray-700">
                        <li><strong>Profiling and Monitoring:</strong> Inject code to measure method execution time, track memory allocations, or count method invocations. This is the foundation of all Application Performance Management (APM) tools like New Relic, Dynatrace, and Elastic APM.</li>
                        <li><strong>Dynamic Behavior Modification:</strong> Alter application logic on the fly. Tools like JRebel use agents to enable "hot-swapping" of class changes at runtime, avoiding costly restarts.</li>
                        <li><strong>Security Auditing:</strong> Intercept method calls to enforce security policies or log access to sensitive data for compliance.</li>
                        <li><strong>Code Coverage Analysis:</strong> Tools like JaCoCo use agents to instrument classes during testing, marking which lines have been executed to generate coverage reports.</li>
                         <li><strong>"Zero-Code" Observability:</strong> The OpenTelemetry agent can automatically instrument dozens of popular libraries to capture traces, metrics, and logs with no code changes required from the developer.</li>
                    </ul>
                </div>
            </section>

            <!-- JVM & ClassLoading Section -->
            <section id="jvm-internals" class="content-section space-y-8">
                <h2 class="text-4xl font-bold text-[#4A5568] mb-4">JVM Internals: The Foundation</h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">The JVM Startup Sequence</h3>
                    <p class="text-gray-700 mb-6">To understand how agents work, you must first understand the environment they operate in. The JVM lifecycle begins long before your `main` method is called. This interactive timeline walks through the critical steps the JVM takes to go from a command line instruction to a running application. Click each step to learn more.</p>
                    <div id="jvm-flowchart" class="relative pl-8">
                        <!-- JS will populate this -->
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">The ClassLoader Delegation Model</h3>
                    <p class="text-gray-700 mb-4">Java's security and stability rely on its hierarchical ClassLoader system. When a class needs to be loaded, the request follows a strict parent-first delegation chain. This prevents core Java classes from being spoofed and ensures a class is loaded only once. This predictable flow is precisely what allows an agent to intercept and transform class bytecode.</p>
                    <p class="text-gray-700 mb-6">Enter a class name below (e.g., `com.mycompany.MyApp` or `java.lang.String`) to see how the delegation model would handle the request.</p>
                    
                    <div class="flex items-center space-x-2 mb-6">
                        <input id="classloader-input" type="text" placeholder="com.mycompany.MyApp" class="flex-grow p-2 border rounded-md focus:ring-2 focus:ring-[#6A8EAE] focus:outline-none">
                        <button id="classloader-button" class="bg-[#6A8EAE] text-white px-4 py-2 rounded-md hover:bg-opacity-90">Simulate</button>
                    </div>

                    <div id="classloader-diagram" class="relative flex flex-col items-center space-y-2 p-4 bg-gray-50 rounded-lg">
                        <div id="cl-bootstrap" class="w-full md:w-1/2 p-4 border-2 border-gray-300 rounded-lg text-center bg-white shadow">
                            <h4 class="font-bold">Bootstrap ClassLoader</h4>
                            <p class="text-sm text-gray-500">Loads core Java APIs (e.g., `java.lang.Object`). Native code.</p>
                        </div>
                        <div class="text-2xl text-gray-400">↓</div>
                        <div id="cl-platform" class="w-full md:w-1/2 p-4 border-2 border-gray-300 rounded-lg text-center bg-white shadow">
                            <h4 class="font-bold">Platform ClassLoader</h4>
                            <p class="text-sm text-gray-500">Loads platform extensions.</p>
                        </div>
                         <div class="text-2xl text-gray-400">↓</div>
                        <div id="cl-system" class="w-full md:w-1/2 p-4 border-2 border-gray-300 rounded-lg text-center bg-white shadow">
                            <h4 class="font-bold">System/App ClassLoader</h4>
                            <p class="text-sm text-gray-500">Loads from application classpath.</p>
                        </div>
                        <div id="cl-request" class="absolute bg-[#6A8EAE] text-white text-sm p-2 rounded-lg shadow-xl" style="opacity: 0; transition: all 0.5s ease;">Request</div>
                    </div>
                </div>
            </section>
            
            <!-- Agent Lifecycle Section -->
            <section id="agent-lifecycle" class="content-section space-y-8">
                <h2 class="text-4xl font-bold text-[#4A5568] mb-4">Agent Lifecycle: Static vs. Dynamic</h2>
                 <p class="text-gray-700 mb-4">A Java Agent can be loaded in one of two ways: statically at JVM startup, or dynamically into an already running JVM. Understanding the difference is key to choosing the right approach for your use case, whether it's for continuous monitoring or on-demand troubleshooting.</p>
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="bg-white p-6 rounded-lg shadow-md space-y-4">
                        <h3 class="text-2xl font-semibold text-[#6A8EAE]">Static Loading</h3>
                        <p>Specified at JVM launch, this is the most common method for tools that need to be active for the entire application lifecycle, like APM agents.</p>
                        <div>
                            <h4 class="font-semibold">Entry Point:</h4>
                            <p class="bg-gray-100 p-2 rounded-md font-mono text-sm">public static void premain(String args, Instrumentation inst)</p>
                        </div>
                        <div>
                            <h4 class="font-semibold">Manifest Key:</h4>
                             <p class="bg-gray-100 p-2 rounded-md font-mono text-sm">Premain-Class: com.example.MyAgent</p>
                        </div>
                         <div>
                            <h4 class="font-semibold">Loading Trigger:</h4>
                            <p class="bg-gray-100 p-2 rounded-md font-mono text-sm">java -javaagent:my-agent.jar MyApp</p>
                        </div>
                         <div>
                            <h4 class="font-semibold">Use Case:</h4>
                            <p>Always-on monitoring, code coverage, bootstrap instrumentation.</p>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md space-y-4">
                        <h3 class="text-2xl font-semibold text-[#6A8EAE]">Dynamic Loading</h3>
                        <p>Attached to a live, running JVM without a restart. This is a game-changer for production diagnostics and troubleshooting.</p>
                        <div>
                            <h4 class="font-semibold">Entry Point:</h4>
                            <p class="bg-gray-100 p-2 rounded-md font-mono text-sm">public static void agentmain(String args, Instrumentation inst)</p>
                        </div>
                        <div>
                            <h4 class="font-semibold">Manifest Key:</h4>
                             <p class="bg-gray-100 p-2 rounded-md font-mono text-sm">Agent-Class: com.example.MyAgent</p>
                        </div>
                         <div>
                            <h4 class="font-semibold">Loading Trigger:</h4>
                            <p class="bg-gray-100 p-2 rounded-md font-mono text-sm">VirtualMachine.attach(pid).loadAgent(...)</p>
                        </div>
                         <div>
                            <h4 class="font-semibold">Use Case:</h4>
                            <p>On-demand profiling, debugging live issues, toggling features.</p>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- Instrumentation API Section -->
            <section id="instrumentation-api" class="content-section space-y-8">
                <h2 class="text-4xl font-bold text-[#4A5568] mb-4">The Instrumentation API</h2>
                 <p class="text-gray-700 mb-4">The `java.lang.instrument` package is the agent's toolkit. It provides the two core interfaces that make instrumentation possible: `Instrumentation` and `ClassFileTransformer`. Together, they form the bridge between your agent and the JVM's class loading machinery.</p>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">The `Instrumentation` Interface</h3>
                    <p class="text-gray-700 leading-relaxed mb-4">
                        This is the agent's control panel, passed by the JVM to your `premain` or `agentmain` method. It cannot be obtained any other way. It provides the methods to register transformers and to modify classes that have already been loaded.
                    </p>
                    <ul class="list-disc list-inside space-y-2 text-gray-700">
                        <li><code class="font-mono bg-gray-100 p-1 rounded">addTransformer(...)</code>: Registers your transformer to intercept class loading.</li>
                        <li><code class="font-mono bg-gray-100 p-1 rounded">retransformClasses(...)</code>: The key to dynamic instrumentation. Re-runs transformers on already-loaded classes.</li>
                        <li><code class="font-mono bg-gray-100 p-1 rounded">redefineClasses(...)</code>: A more drastic operation to completely replace a class's bytecode, primarily used by debuggers.</li>
                        <li><code class="font-mono bg-gray-100 p-1 rounded">getAllLoadedClasses()</code>: Discovers what's currently running in the JVM.</li>
                        <li><code class="font-mono bg-gray-100 p-1 rounded">getObjectSize(...)</code>: Approximates the memory size of an object.</li>
                    </ul>
                </div>
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">The `ClassFileTransformer` Interface</h3>
                    <p class="text-gray-700 leading-relaxed mb-4">
                        This is where the magic happens. Your agent implements this interface to gain access to a class's bytecode before the JVM finalizes it. Its single method, `transform`, receives the class name and its raw bytecode as a byte array. Your job is to return a new byte array with your modifications, or `null` if you don't want to change the class. This is the hook used to inject timing logic, logging, security checks, and more.
                    </p>
                    <div class="overflow-x-auto">
                        <table class="w-full text-left border-collapse">
                            <thead>
                                <tr class="bg-gray-100">
                                    <th class="p-2 border">Feature</th>
                                    <th class="p-2 border">`retransformClasses`</th>
                                    <th class="p-2 border">`redefineClasses`</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="border">
                                    <td class="p-2 font-semibold">Purpose</td>
                                    <td class="p-2">Instrumentation</td>
                                    <td class="p-2">Hot-swapping, debugging</td>
                                </tr>
                                <tr class="border bg-gray-50">
                                    <td class="p-2 font-semibold">Mechanism</td>
                                    <td class="p-2">Re-applies all transformers to original class bytes</td>
                                    <td class="p-2">Replaces class definition wholesale</td>
                                </tr>
                                <tr class="border">
                                    <td class="p-2 font-semibold">Cooperation</td>
                                    <td class="p-2">Excellent (multi-agent friendly)</td>
                                    <td class="p-2">Poor (last writer wins)</td>
                                </tr>
                                <tr class="border bg-gray-50">
                                    <td class="p-2 font-semibold">Manifest Flag</td>
                                    <td class="p-2">`Can-Retransform-Classes: true`</td>
                                    <td class="p-2">`Can-Redefine-Classes: true`</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
            
            <!-- Bytecode Libraries Section -->
            <section id="bytecode-libraries" class="content-section space-y-8">
                <h2 class="text-4xl font-bold text-[#4A5568] mb-4">Bytecode Manipulation Libraries</h2>
                <p class="text-gray-700 mb-4">Manually editing bytecode is incredibly complex. Any practical agent uses a library to handle the low-level details. The choice of library is a key architectural decision, balancing performance, features, and ease of use. The three titans of transformation are ASM, Javassist, and Byte Buddy.</p>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">At a Glance: Performance vs. Ease of Use</h3>
                    <div class="chart-container">
                        <canvas id="library-comparison-chart"></canvas>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">Detailed Comparison</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-left border-collapse">
                             <thead>
                                <tr class="bg-gray-100">
                                    <th class="p-3 border">Feature</th>
                                    <th class="p-3 border">ASM</th>
                                    <th class="p-3 border">Javassist</th>
                                    <th class="p-3 border">Byte Buddy</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="border">
                                    <td class="p-3 font-semibold">Abstraction Level</td>
                                    <td class="p-3">Low (Bytecode-level)</td>
                                    <td class="p-3">High (Source-level)</td>
                                    <td class="p-3">High (Type-safe, fluent API)</td>
                                </tr>
                                <tr class="border bg-gray-50">
                                    <td class="p-3 font-semibold">Performance</td>
                                    <td class="p-3">Highest</td>
                                    <td class="p-3">Moderate</td>
                                    <td class="p-3">High (uses ASM)</td>
                                </tr>
                                <tr class="border">
                                    <td class="p-3 font-semibold">Ease of Use</td>
                                    <td class="p-3">Difficult</td>
                                    <td class="p-3">Easy</td>
                                    <td class="p-3">Moderate to Easy</td>
                                </tr>
                                <tr class="border bg-gray-50">
                                    <td class="p-3 font-semibold">Key API Concept</td>
                                    <td class="p-3">Visitor Pattern</td>
                                    <td class="p-3">Source Code Injection</td>
                                    <td class="p-3">Method Delegation</td>
                                </tr>
                                <tr class="border">
                                    <td class="p-3 font-semibold">Best For</td>
                                    <td class="p-3">Frameworks, performance-critical tools</td>
                                    <td class="p-3">Rapid prototyping, simple instrumentation</td>
                                    <td class="p-3">Most modern agent development</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
            
            <!-- Code Lab Section -->
            <section id="code-lab" class="content-section space-y-8">
                 <h2 class="text-4xl font-bold text-[#4A5568] mb-4">Code Lab</h2>
                 <p class="text-gray-700 mb-4">Theory is great, but code is better. This lab contains the complete source for the agents discussed in this guide. Use the tabs to switch between files for each example and use the copy button to grab the code for your own experiments.</p>
                
                <div class="bg-white rounded-lg shadow-md overflow-hidden">
                    <div class="p-6">
                        <h3 class="text-2xl font-semibold text-[#6A8EAE]">Example 1: The "Hello, Agent!" Static Agent</h3>
                        <p class="text-gray-600 mt-2">The most basic static agent. It prints a message during JVM startup to prove it was loaded before the application's `main` method.</p>
                    </div>
                    <div class="code-lab-container" data-example="hello-agent">
                        <div class="border-b border-gray-200 px-6">
                            <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                                <button class="code-tab active" data-file="agent">SimpleAgent.java</button>
                                <button class="code-tab" data-file="app">MyApp.java</button>
                                <button class="code-tab" data-file="manifest">MANIFEST.MF</button>
                            </nav>
                        </div>
                        <div class="p-4">
                            <div class="code-content" data-file="agent">
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre class="bg-gray-800 text-white p-4 rounded-lg text-sm overflow-x-auto"><code>package com.example.agent;
import java.lang.instrument.Instrumentation;

public class SimpleAgent {
    public static void premain(String agentArgs, Instrumentation inst) {
        System.out.println("Hello from SimpleAgent!");
        System.out.println("Arguments: " + agentArgs);
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="code-content" data-file="app" style="display: none;">
                                <div class="code-block">
                                     <button class="copy-button">Copy</button>
                                    <pre class="bg-gray-800 text-white p-4 rounded-lg text-sm overflow-x-auto"><code>public class MyApp {
    public static void main(String[] args) {
        System.out.println("Hello from MyApp's main method!");
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="code-content" data-file="manifest" style="display: none;">
                                <div class="code-block">
                                     <button class="copy-button">Copy</button>
                                    <pre class="bg-gray-800 text-white p-4 rounded-lg text-sm overflow-x-auto"><code>Manifest-Version: 1.0
Premain-Class: com.example.agent.SimpleAgent
</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                 <div class="bg-white rounded-lg shadow-md overflow-hidden">
                    <div class="p-6">
                        <h3 class="text-2xl font-semibold text-[#6A8EAE]">Example 2: Method Execution Timer</h3>
                        <p class="text-gray-600 mt-2">A more practical agent that uses a `ClassFileTransformer` and the Javassist library to inject bytecode that measures and prints the execution time of a method.</p>
                    </div>
                    <div class="code-lab-container" data-example="timer-agent">
                        <div class="border-b border-gray-200 px-6">
                            <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                                <button class="code-tab active" data-file="transformer">DurationTransformer.java</button>
                                <button class="code-tab" data-file="agent">DurationAgent.java</button>
                                <button class="code-tab" data-file="app">MyWorker.java</button>
                            </nav>
                        </div>
                        <div class="p-4">
                             <div class="code-content" data-file="transformer">
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre class="bg-gray-800 text-white p-4 rounded-lg text-sm overflow-x-auto"><code>package com.example.agent;
import java.lang.instrument.*;
import java.security.ProtectionDomain;
import javassist.*;

public class DurationTransformer implements ClassFileTransformer {
    @Override
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
                            ProtectionDomain protectionDomain, byte[] classfileBuffer) {
        if (className.equals("com/example/app/MyWorker")) {
            try {
                ClassPool cp = ClassPool.getDefault();
                CtClass cc = cp.get("com.example.app.MyWorker");
                CtMethod m = cc.getDeclaredMethod("doWork");
                m.addLocalVariable("startTime", CtClass.longType);
                m.insertBefore("startTime = System.nanoTime();");
                m.insertAfter("{ long et = System.nanoTime() - startTime; System.out.println(\\"Method executed in \\" + et + \\" ns\\"); }", true);
                byte[] byteCode = cc.toBytecode();
                cc.detach();
                return byteCode;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        return null;
    }
}</code></pre>
                                </div>
                            </div>
                             <div class="code-content" data-file="agent" style="display: none;">
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre class="bg-gray-800 text-white p-4 rounded-lg text-sm overflow-x-auto"><code>package com.example.agent;
import java.lang.instrument.Instrumentation;

public class DurationAgent {
    public static void premain(String agentArgs, Instrumentation inst) {
        inst.addTransformer(new DurationTransformer());
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="code-content" data-file="app" style="display: none;">
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre class="bg-gray-800 text-white p-4 rounded-lg text-sm overflow-x-auto"><code>package com.example.app;
import java.util.concurrent.TimeUnit;

public class MyWorker {
    public void doWork() throws InterruptedException {
        System.out.println("Worker is doing work...");
        TimeUnit.SECONDS.sleep(2);
        System.out.println("Worker finished.");
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- Production Guide Section -->
            <section id="production-guide" class="content-section space-y-8">
                 <h2 class="text-4xl font-bold text-[#4A5568] mb-4">Production-Ready Agents</h2>
                 <p class="text-gray-700 mb-4">Building a toy agent is one thing. Shipping a robust, reliable agent that can be safely deployed to production is another. It requires confronting several critical engineering challenges head-on.</p>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">The Dependency Dilemma & "JAR Hell"</h3>
                    <p class="text-gray-700 leading-relaxed">
                        <strong>The Problem:</strong> Your agent and the application it instruments live in the same JVM. If both use the same library (e.g., Gson, Guava) but different versions, you have a classic "JAR Hell" scenario. The JVM might load the application's older version, causing your agent to crash with a `MethodNotFoundException`.
                        <br><br>
                        <strong>The Solution:</strong> You must create a self-contained "uber-JAR" and, critically, **shade** your dependencies. Shading (or relocating) renames the packages of your agent's dependencies (e.g., `com.google.gson` becomes `my.agent.shaded.com.google.gson`). This makes your agent's dependencies completely invisible and inaccessible to the application, eliminating any chance of conflict. This is handled by build plugins like `maven-shade-plugin` or Gradle's `shadowJar`.
                    </p>
                </div>
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">The Isolation Principle & ClassLoaders</h3>
                    <p class="text-gray-700 leading-relaxed">
                        An agent's classes are loaded by a separate, isolated class loader, not the application's. This is great for preventing interference but creates a problem: how does code you inject into an application class call a utility method inside your isolated agent? The application class can't see the agent's classes.
                        <br><br>
                        <strong>The Solution:</strong> A common pattern is **bootstrap class loader injection**. The agent programmatically adds a small JAR of essential, shared utility classes to the bootstrap class loader's path. Since the bootstrap loader is the ancestor of all others, these classes become globally visible to both your agent and the instrumented application code, forming a bridge between the two isolated worlds.
                    </p>
                </div>
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-2xl font-semibold text-[#6A8EAE] mb-4">Security Manager & Permissions</h3>
                    <p class="text-gray-700 leading-relaxed">
                        In secured environments running with a Java Security Manager, agents will fail unless they are explicitly granted permissions in a policy file. Since agents are highly privileged, they often need broad permissions.
                    </p>
                     <div class="code-block mt-4">
                        <button class="copy-button">Copy</button>
                        <pre class="bg-gray-800 text-white p-4 rounded-lg text-sm overflow-x-auto"><code>// Example policy file grant
grant codeBase "file:/path/to/my-agent.jar" {
    permission java.security.AllPermission;
};</code></pre>
                    </div>
                </div>
            </section>
        </main>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const navLinks = document.querySelectorAll('#main-nav a');
    const contentSections = document.querySelectorAll('.content-section');

    function navigateTo(hash) {
        navLinks.forEach(link => {
            if (link.getAttribute('href') === hash) {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });

        contentSections.forEach(section => {
            if ('#' + section.id === hash) {
                section.classList.add('active');
            } else {
                section.classList.remove('active');
            }
        });

        // Special init for sections with dynamic content
        if (hash === '#bytecode-libraries') {
            initBytecodeChart();
        }
        if (hash === '#jvm-internals') {
            initJvmFlowchart();
        }
    }

    navLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const targetHash = e.currentTarget.getAttribute('href');
            window.location.hash = targetHash;
        });
    });

    window.addEventListener('hashchange', () => {
        const hash = window.location.hash || '#overview';
        navigateTo(hash);
    });

    // Initial load
    const initialHash = window.location.hash || '#overview';
    navigateTo(initialHash);
    
    // Code Lab Tabs
    const codeLabContainers = document.querySelectorAll('.code-lab-container');
    codeLabContainers.forEach(container => {
        const tabs = container.querySelectorAll('.code-tab');
        const contents = container.querySelectorAll('.code-content');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active', 'text-[#6A8EAE]', 'border-[#6A8EAE]', 'border-b-2'));
                tabs.forEach(t => t.classList.add('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300', 'border-transparent'));
                
                tab.classList.add('active', 'text-[#6A8EAE]', 'border-[#6A8EAE]', 'border-b-2');
                tab.classList.remove('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300', 'border-transparent');

                const file = tab.dataset.file;
                contents.forEach(content => {
                    if (content.dataset.file === file) {
                        content.style.display = 'block';
                    } else {
                        content.style.display = 'none';
                    }
                });
            });
        });
        // Style active tab
        container.querySelector('.code-tab.active').style.cssText = 'color: #6A8EAE; border-color: #6A8EAE; border-bottom-width: 2px;';
        const inactiveTabs = container.querySelectorAll('.code-tab:not(.active)');
        inactiveTabs.forEach(it => it.style.cssText = 'color: #4A5568; border-color: transparent;');
    });
    
    // Copy buttons
    document.querySelectorAll('.copy-button').forEach(button => {
        button.addEventListener('click', (e) => {
            const code = e.target.nextElementSibling.querySelector('code').innerText;
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.innerText;
                button.innerText = 'Copied!';
                setTimeout(() => {
                    button.innerText = originalText;
                }, 2000);
            });
        });
    });

    // Bytecode Chart
    let bytecodeChart = null;
    function initBytecodeChart() {
        const ctx = document.getElementById('library-comparison-chart');
        if (!ctx || bytecodeChart) return;
        
        bytecodeChart = new Chart(ctx.getContext('2d'), {
            type: 'bar',
            data: {
                labels: ['ASM', 'Javassist', 'Byte Buddy'],
                datasets: [{
                    label: 'Performance',
                    data: [10, 6, 9],
                    backgroundColor: 'rgba(74, 85, 104, 0.7)',
                    borderColor: 'rgba(74, 85, 104, 1)',
                    borderWidth: 1
                }, {
                    label: 'Ease of Use',
                    data: [2, 9, 8],
                    backgroundColor: 'rgba(106, 142, 174, 0.7)',
                    borderColor: 'rgba(106, 142, 174, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 10,
                         ticks: {
                             stepSize: 2
                         },
                        grid: {
                            color: 'rgba(0,0,0,0.05)'
                        }
                    },
                    x: {
                         grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    },
                    title: {
                        display: true,
                        text: 'Relative Comparison (10 = Highest/Easiest)'
                    }
                }
            }
        });
    }

    // JVM Flowchart
    function initJvmFlowchart() {
        const container = document.getElementById('jvm-flowchart');
        if (container.childElementCount > 0) return; // already initialized

        const steps = [
            { title: "Argument Parsing", content: "The `java` command launches a native OS process. This process parses all command-line arguments, including JVM options (`-Xmx`), system properties (`-D`), and the main class name." },
            { title: "Environment Setup", content: "The JVM inspects the host system (CPU cores, memory) to self-tune, for example by selecting the appropriate Garbage Collector (e.g., G1 GC)." },
            { title: "Memory Allocation", content: "Core memory regions are allocated, including the large, contiguous Java Heap for objects and Metaspace for class metadata." },
            { title: "Agent Loading (Static)", content: "If `-javaagent` is present, the JVM loads the agent JAR, finds the `Premain-Class` in its manifest, and executes its `premain` method. This happens *before* any application code runs." },
            { title: "Bootstrap ClassLoader", content: "The native Bootstrap ClassLoader is created to load fundamental Java classes like `java.lang.Object`." },
            { title: "Initial Class Loading", content: "The JVM uses the class loading mechanism to load the application's main class." },
            { title: "Linking & Initialization", content: "The main class is verified for correctness, its static fields are prepared, and its static initializer blocks are executed." },
            { title: "Invoke `main` Method", content: "Finally, the JVM invokes the `public static void main(String[] args)` method, handing control over to the application." }
        ];

        steps.forEach((step, index) => {
            const stepWrapper = document.createElement('div');
            stepWrapper.className = 'relative pb-8';
            
            const line = document.createElement('div');
            line.className = 'absolute top-4 left-4 -ml-px mt-0.5 h-full w-0.5 bg-gray-300';
            if (index < steps.length) stepWrapper.appendChild(line);

            const stepContent = `
                <div class="relative flex items-start space-x-3 group">
                    <div>
                        <div class="h-8 w-8 bg-white rounded-full ring-4 ring-white flex items-center justify-center cursor-pointer flow-step-trigger">
                             <span class="text-[#6A8EAE] font-bold">${index + 1}</span>
                        </div>
                    </div>
                    <div class="min-w-0 flex-1 pt-1.5">
                        <div class="text-md font-semibold text-gray-700 cursor-pointer flow-step-trigger">${step.title}</div>
                        <div class="flow-step-content text-sm text-gray-600 mt-2">${step.content}</div>
                    </div>
                </div>`;
            stepWrapper.innerHTML += stepContent;
            container.appendChild(stepWrapper);
        });

        container.querySelectorAll('.flow-step-trigger').forEach(trigger => {
            trigger.addEventListener('click', (e) => {
                const content = e.currentTarget.closest('.group').querySelector('.flow-step-content');
                if (content.style.maxHeight && content.style.maxHeight !== '0px') {
                    content.style.maxHeight = '0px';
                } else {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            });
        });
    }

    // ClassLoader simulation
    const clButton = document.getElementById('classloader-button');
    const clInput = document.getElementById('classloader-input');

    clButton.addEventListener('click', () => {
        const className = clInput.value || 'com.mycompany.MyApp';
        const isCoreClass = className.startsWith('java.') || className.startsWith('javax.');
        
        const requestEl = document.getElementById('cl-request');
        const systemEl = document.getElementById('cl-system');
        const platformEl = document.getElementById('cl-platform');
        const bootstrapEl = document.getElementById('cl-bootstrap');
        
        const systemPos = systemEl.offsetTop + systemEl.offsetHeight / 2;
        const platformPos = platformEl.offsetTop + platformEl.offsetHeight / 2;
        const bootstrapPos = bootstrapEl.offsetTop + bootstrapEl.offsetHeight / 2;

        requestEl.innerText = `Load ${className}`;
        requestEl.style.top = `${systemPos - 15}px`;
        requestEl.style.opacity = '1';
        requestEl.style.borderColor = '#6A8EAE';
        
        systemEl.style.borderColor = '#6A8EAE';
        platformEl.style.borderColor = '#9f9f9f';
        bootstrapEl.style.borderColor = '#9f9f9f';
        
        let foundAt = 'system';
        if (isCoreClass) {
            foundAt = 'bootstrap';
        }

        setTimeout(() => {
            requestEl.style.top = `${platformPos - 15}px`;
            systemEl.style.borderColor = '#9f9f9f';
            platformEl.style.borderColor = '#6A8EAE';
        }, 1000);

        setTimeout(() => {
            requestEl.style.top = `${bootstrapPos - 15}px`;
            platformEl.style.borderColor = '#9f9f9f';
            bootstrapEl.style.borderColor = '#6A8EAE';
        }, 2000);
        
        if (foundAt === 'bootstrap') {
             setTimeout(() => {
                bootstrapEl.style.borderColor = 'rgb(74 222 128)'; // green-400
                requestEl.innerText = 'Found!';
            }, 3000);
        } else {
             setTimeout(() => {
                requestEl.style.top = `${platformPos - 15}px`;
                bootstrapEl.style.borderColor = '#9f9f9f';
                platformEl.style.borderColor = '#6A8EAE';
            }, 3000);
             setTimeout(() => {
                requestEl.style.top = `${systemPos - 15}px`;
                platformEl.style.borderColor = '#9f9f9f';
                systemEl.style.borderColor = '#6A8EAE';
            }, 4000);
             setTimeout(() => {
                systemEl.style.borderColor = 'rgb(74 222 128)'; // green-400
                requestEl.innerText = 'Found!';
            }, 5000);
        }

        setTimeout(() => {
            requestEl.style.opacity = '0';
            systemEl.style.borderColor = '#9f9f9f';
            platformEl.style.borderColor = '#9f9f9f';
            bootstrapEl.style.borderColor = '#9f9f9f';
        }, (foundAt === 'bootstrap' ? 4500 : 6500));
    });

});
</script>
</body>
</html>
